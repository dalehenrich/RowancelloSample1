#!/usr/bin/env superdoit_stone
options
{
	SuperDoitOptionalOptionWithRequiredArg long: 'projectsHome'.
	SuperDoitOptionalOptionWithRequiredArg long: 'projectName'.
	SuperDoitOptionalOptionWithNoArg long: 'validate'.
	SuperDoitOptionalOptionWithNoArg long: 'stats'.
	SuperDoitOptionalOptionWithNoArg long: 'custom'.
	SuperDoitOptionalOptionWithNoArg long: 'packageNames'.
}
%
#
#options
#{
#	SuperDoitOptionalOptionWithNoArg long: 'noarg'.
#	SuperDoitOptionalOptionWithNoArg long: 'noarg' short: 'n'.
#
#	SuperDoitOptionalOptionWithRequiredArg long: 'optional'.
#	SuperDoitOptionalOptionWithRequiredArg long: 'optional' default: 'default'.
#	SuperDoitOptionalOptionWithRequiredArg long: 'optional' short: 'o'.
#	SuperDoitOptionalOptionWithRequiredArg long: 'optional' short: 'o' default: 'default'.
#
#	SuperDoitRequiredOptionWithRequiredArg long: 'required'.
#	SuperDoitRequiredOptionWithRequiredArg long: 'required' short: 'r'.
#}
#%
#
usage
-----
USAGE 
  # with GS_HOME set (<stone-name> optional if run in $GS_HOME/servers/stones/<stone-name> directory)
  $basename [--help | -h] [--debug | -D]  [--debugGem] [-- [<stone-name> [<topaz-command-line-args>] ] ]
  # with GEMSTONE set
  $basename [--help | -h] [--debug | -D]  [--debugGem] -- (-r | -l | -L) -I <path-to-.topazini> [<topaz-command-line-args>]

DESCRIPTION
  I'm imagining that theres is a way to compress the current component structure which is distributed across
  a complex hiearchy of components where each component has a single condition and may or may not resolve to a 
  list of packages or projects ... 

  Some (or most) of the components are transitive where they simply provide a condition that is ANDed with their 
  parent components and may not provide any package/project info at all ...

	I'll attempt to tease that structure out with this script.

OPTIONS
  <stone-name>               Name of the GsDevKit_home stone. <stone-name> argument
                             may be skipped if the script is run in a GsDevKit_home
                             stone directory (i.e., $GS_HOME/server/stones/<stone-name>
  <topaz-command-line-args>  topaz options that should be passed to topaz when running
                             running the script
  -h, --help                 display usage message
  -D, --debug                bring up topaz debugger in the event of a script error
  --debugGem                 If terminal is connected to stdout, bring up debugger. If not,
                             dump stack to stdout and wait for topaz to attach using topaz
                             DEBUGGEM command.

EXAMPLES
  $basename --help                           -- gs_351             # with GS_HOME set
  $basename -h                               -- -l -I ./.topazini  # with GEMSTONE set
  $basename -D <script-arguments>            <topaz-arguments>
  $basename --debugGem <script-arguments>    <topaz-arguments>
  $basename <script-arguments>               <topaz-arguments>

  $basename --projectsHome=/bosch1/users/dhenrich/_stones/git/ \
            --projectName=RowanSample9V4_0024 \
            file:///bosch1/users/dhenrich/_stones/git/RowanSample9V4/rowan/specs/spec_0024.ston \
            Core -D

  $basename --projectsHome=/bosch1/users/dhenrich/_stones/git/ \
            --projectName=RowanSample9V4_0070 \
            file:///bosch1/users/dhenrich/_stones/git/RowanSample9V4/rowan/specs/spec_0070.ston \
            Core -D

   $basename --projectsHome=/bosch1/users/dhenrich/_stones/git/ \
            --projectName=RowanV3 \
            file:///bosch1/users/dhenrich/_stones/git/RowanV3/rowan/specs/Rowan.ston \
            Rowan SharedTests Upgrade -D

   $basename --projectsHome=/bosch1/users/dhenrich/_stones/git/ \
            --projectName=RowanV3 \
            file:///bosch1/users/dhenrich/_stones/git/RowanV3/rowan/specs/Rowan.ston \
            Rowan SharedTests Upgrade --validate -D
  -----
%
method
calculatePackageNamesFor: attributes clusters: clusterNames projectClusters: projectClusters
	| packageNames context |
	packageNames := Set new.
	context := RwCAQContext new.
	attributes do: [:attribute |
		context set: attribute ].
	context
		set: 'gemstone';
		set: 'gemstone.version'
			to: ((System gemVersionReport at: 'gsVersion') asRwGemStoneVersionNumber);
		yourself.

	clusterNames do: [:clusterName |
		| cluster ast evaluator result |
		cluster := projectClusters clusterNamed: clusterName.
		cluster subclusters do: [:subclusterName |
			| subcluster |
			subcluster := projectClusters subclusterNamed: subclusterName.
			ast := RwCAQParser new parse: subcluster condition.
			evaluator := RwCAQEvaluator
				context: context
				ast: ast.
			result := evaluator evaluate.
			result ifTrue: [ 
				packageNames addAll: subcluster packageNames ] ] ].
	^ packageNames sort
%
method
commonConditions: projectClusters against: resolvedProject
	"looking for subclusters with the same conditions"
	| dict clusters analysis total |
	total := 0.
	analysis := Dictionary new.
	dict := Dictionary new.
	clusters := projectClusters clusters.
	projectClusters subclusters do: [:subcluster |
		(dict at: subcluster condition ifAbsentPut: [ Set new ]) add: subcluster ].
	dict keys do: [:condition | (dict at: condition) size = 1 ifTrue: [ dict removeKey: condition]].
	clusters do: [:cluster |
		| clusterDict |
		clusterDict := Dictionary new.
		analysis at: cluster clusterName put: clusterDict.
		dict keys do: [:condition | 
			| count |
			count := 0.
			((dict at: condition) collect: [:each | each subclusterName ]) do: [:subclusterName |
				(cluster subclusters includes: subclusterName) ifTrue: [ count := count + 1 ].
				count > 1 ifTrue: [ clusterDict at: subclusterName put: count -1 . total := total + count - 1 ].
			 ] ] ].
"	^ { total . analysis . self calculateStats: projectClusters against: resolvedProject }."
	^ (self validateProjectClusters: projectClusters against: resolvedProject)
			add: total;
			add: analysis;
			yourself
%
method
customAnalysis:  projectClusters against: resolvedProject
	^ self commonConditions: projectClusters against: resolvedProject
%
method
calculateStats: projectClusters against: resolvedProject
	| packageNames stats |
	packageNames:= resolvedProject packageNames.
	stats := Dictionary new.
	stats at: 'packages' put: packageNames size.
	stats at: 'clusters' put: projectClusters clusters size. 
	stats at: 'subclusters' put: projectClusters subclusters size. 
	stats at: 'components' put: resolvedProject _projectComponents components size.
	^ stats
%
method
validateProjectClusters: projectClusters against: resolvedProject
	| packageNames references |
	packageNames:= resolvedProject packageNames.
	references := Dictionary new.
	packageNames do: [:packageName |
		| refs |
		refs := projectClusters referencesToPackageNamed: packageName.
		references at: packageName put: refs ].
	self stats
		ifTrue: [ ^ { self calculateStats: projectClusters against: resolvedProject . references . projectClusters } ].
	^ {references . projectClusters }
%
method
analyzeClustersInProject: resolvedProject
"
	For each load component create an cluster, follow the chain of subcomponents, accumulating a conditional 
	expression for each component visited. When a component contains a package or project reference create 
	an subcluster to record the expression and references. Ideally I should be able identify shared subclusters.

	Running through process of converting the components to clusters and subclusers ... and returning 
	the _projectClusters object ... which when displayed with STON is pretty reasonable result.

  Will need to run against multiple projects work out the kinks and validate the approach.
"
	| projectClusters |
	projectClusters := resolvedProject clusterAnalysis.
	self custom
		ifTrue: [ ^ self customAnalysis: projectClusters against: resolvedProject  ].
	self validate
		ifTrue: [ ^ self validateProjectClusters: projectClusters against: resolvedProject ].
	self stats
		ifTrue: [ ^ { self calculateStats: projectClusters against: resolvedProject . projectClusters } ].
	^ projectClusters
%
doit

	| resolvedProject loadSpec loadComponentNames x calculated actual projectClusters |
	self projectsHome
		ifNil: [
			(System gemEnvironmentVariable: 'ROWAN_PROJECTS_HOME') 
				ifNil: [ self error: 'ROWAN_PROJECTS_HOME not definied. Define ROWAN_PROJECTS_HOME or use --projectsHome option' ] ]
		ifNotNil: [:rowanProjectsHome | System gemEnvironmentVariable: 'ROWAN_PROJECTS_HOME' put: rowanProjectsHome ].
	self positionalArgs size < 1 ifTrue: [ self error: 'Must provide the loadSpecUrl as first positional argument'].
	loadComponentNames := self positionalArgs copyFrom: 2 to: self positionalArgs size.
	
	loadSpec := (RwSpecification fromUrl: (self positionalArgs at: 1)) copyAsV4_cluster. 

	"note when reading from disk we have to make sure that ALL components are read from disk 
		so we have to arrange to set all of the conditions to true - eventually need to set on command line?"
self projectName = 'RowanV3' ifTrue: [
	loadSpec 
		projectAlias: self projectName;
		diskUrl: ('$ROWAN_PROJECTS_HOME' asFileReference / self projectName) pathString;
		componentNames: loadComponentNames ]
ifFalse: [
	| baseProjectName |
	baseProjectName := 'RowanSample9V4'.
	self projectName = 'RowanSample9V4_0070'
		ifTrue: [
			loadSpec 
				projectAlias: baseProjectName;
				diskUrl: ('$ROWAN_PROJECTS_HOME' asFileReference / baseProjectName) pathString;
				componentNames: loadComponentNames]
		ifFalse: [
			| x1 x2 |
			self projectName = 'RowanSample9V4_0024'
				ifTrue: [
					loadSpec 
						projectAlias: baseProjectName;
						diskUrl: ('$ROWAN_PROJECTS_HOME' asFileReference / baseProjectName) pathString;
						componentNames: loadComponentNames ]
				ifFalse: [ self error: 'Unknown label: ', self projectName printString, '. Expected RowanV3, RowanSample9V4_0070, or RowanSample9V4_0024' ] ] ].
	"all project components are read when the loadSpec is read"
	resolvedProject := loadSpec read.
	projectClusters := resolvedProject projectDefinition clusterAnalysis.
	calculated := (self 
				calculatePackageNamesFor: {	'stubs' .  'tonel' .  'obsolete' . 'v2' . 'v2Only' . 'examples' . 'shared' . 'v3' . 'common' } 
				clusters: loadComponentNames 
				projectClusters: projectClusters) asSet.
	actual := resolvedProject packageNames asSet.
	^ { 'dif A-C' -> (actual - calculated) sort . 'dif C-A' -> (calculated - actual) sort . 'actual' -> actual sort . 'calculated' ->calculated sort  . 'projectClusters' -> projectClusters }
%
