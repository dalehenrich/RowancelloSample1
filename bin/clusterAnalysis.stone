#!/usr/bin/env superdoit_stone
options
{
	SuperDoitOptionalOptionWithRequiredArg long: 'projectsHome'.
	SuperDoitOptionalOptionWithRequiredArg long: 'projectName'.
	SuperDoitOptionalOptionWithNoArg long: 'validate'.
	SuperDoitOptionalOptionWithNoArg long: 'stats'.
	SuperDoitOptionalOptionWithNoArg long: 'custom'.
	SuperDoitOptionalOptionWithNoArg long: 'packageNames'.
	SuperDoitRequiredOptionWithRequiredArg long: 'resultsFile' .
}
%
#
#options
#{
#	SuperDoitOptionalOptionWithNoArg long: 'noarg'.
#	SuperDoitOptionalOptionWithNoArg long: 'noarg' short: 'n'.
#
#	SuperDoitOptionalOptionWithRequiredArg long: 'optional'.
#	SuperDoitOptionalOptionWithRequiredArg long: 'optional' default: 'default'.
#	SuperDoitOptionalOptionWithRequiredArg long: 'optional' short: 'o'.
#	SuperDoitOptionalOptionWithRequiredArg long: 'optional' short: 'o' default: 'default'.
#
#	SuperDoitRequiredOptionWithRequiredArg long: 'required'.
#	SuperDoitRequiredOptionWithRequiredArg long: 'required' short: 'r'.
#}
#%
#
usage
-----
USAGE 
  # with GS_HOME set (<stone-name> optional if run in $GS_HOME/servers/stones/<stone-name> directory)
  $basename [--help | -h] [--debug | -D]  [--debugGem] [-- [<stone-name> [<topaz-command-line-args>] ] ]
  # with GEMSTONE set
  $basename [--help | -h] [--debug | -D]  [--debugGem] -- (-r | -l | -L) -I <path-to-.topazini> [<topaz-command-line-args>]

DESCRIPTION
  I'm imagining that theres is a way to compress the current component structure which is distributed across
  a complex hiearchy of components where each component has a single condition and may or may not resolve to a 
  list of packages or projects ... 

  Some (or most) of the components are transitive where they simply provide a condition that is ANDed with their 
  parent components and may not provide any package/project info at all ...

	I'll attempt to tease that structure out with this script.

OPTIONS
  <stone-name>               Name of the GsDevKit_home stone. <stone-name> argument
                             may be skipped if the script is run in a GsDevKit_home
                             stone directory (i.e., $GS_HOME/server/stones/<stone-name>
  <topaz-command-line-args>  topaz options that should be passed to topaz when running
                             running the script
  -h, --help                 display usage message
  -D, --debug                bring up topaz debugger in the event of a script error
  --debugGem                 If terminal is connected to stdout, bring up debugger. If not,
                             dump stack to stdout and wait for topaz to attach using topaz
                             DEBUGGEM command.

EXAMPLES
  $basename --help                           -- gs_351             # with GS_HOME set
  $basename -h                               -- -l -I ./.topazini  # with GEMSTONE set
  $basename -D <script-arguments>            <topaz-arguments>
  $basename --debugGem <script-arguments>    <topaz-arguments>
  $basename <script-arguments>               <topaz-arguments>

  $basename --projectsHome=/bosch1/users/dhenrich/_stones/git/ \
            --projectName=RowanSample9V4_0024 \
            file:///bosch1/users/dhenrich/_stones/git/RowanSample9V4/rowan/specs/spec_0024.ston \
            --resultsFile='/bosch1/users/dhenrich/_stones/git/RowancelloSample1/generated/rowanSample9V4_spec_0024_components.ston' \
            Core -D

  $basename --projectsHome=/bosch1/users/dhenrich/_stones/git/ \
            --projectName=RowanSample9V4_0032 \
            file:///bosch1/users/dhenrich/_stones/git/RowanSample9V4/rowan/specs/spec_0032.ston \
            --resultsFile='/bosch1/users/dhenrich/_stones/git/RowancelloSample1/generated/rowanSample9V4_spec_0032_components.ston' \
            RowanSample9V4 -D

  $basename --projectsHome=/bosch1/users/dhenrich/_stones/git/ \
            --projectName=RowanSample9V4_0070 \
            file:///bosch1/users/dhenrich/_stones/git/RowanSample9V4/rowan/specs/spec_0070.ston \
            --resultsFile='/bosch1/users/dhenrich/_stones/git/RowancelloSample1/generated/rowanSample9V4_spec_0070_components.ston' \
            Core -D

   $basename --projectsHome=/bosch1/users/dhenrich/_stones/git/ \
            --projectName=RowanV3 \
            file:///bosch1/users/dhenrich/_stones/git/RowanV3/rowan/specs/Rowan.ston \
            --resultsFile='/bosch1/users/dhenrich/_stones/git/RowancelloSample1/generated/rowanV3_Rowan_components.ston' \
            Rowan SharedTests Upgrade -D

   $basename --projectsHome=/bosch1/users/dhenrich/_stones/git/ \
            --projectName=RowanV3 \
            file:///bosch1/users/dhenrich/_stones/git/RowanV3/rowan/specs/Rowan.ston \
            --resultsFile='/bosch1/users/dhenrich/_stones/git/RowancelloSample1/generated/rowanV3_Rowan_components.ston' \
            Rowan SharedTests Upgrade --validate -D
  -----
%
method
calculatePackageNamesFor: unused clusters: clusterNames projectClusters: projectClusters
	| packageNames context |
	context := projectClusters expressionContext.
	packageNames := Set new.
	clusterNames do: [:clusterName |
		| cluster ast evaluator stack index|
		cluster := projectClusters clusterNamed: clusterName.
		packageNames addAll: cluster packageNames.
		stack := Array new.
		stack add: cluster subclusters.
		index := 1.
		[index > stack size] 
			whileFalse: [
				index to: stack size do: [:i | 
					(stack at: i) do: [:subclusterName |
						| subcluster |
						subcluster := projectClusters subclusterNamed: subclusterName.
          	ast := RwCAQParser new parse: subcluster condition.                           
          	evaluator := RwCAQEvaluator
          		context: context
            	ast: ast.
          	(evaluator evaluate)
							ifTrue: [
								packageNames addAll: subcluster packageNames ] ] ].
				index := index + 1 ] ].
	^ packageNames sort
%
method
commonConditions: projectClusters against: resolvedProject
	"looking for subclusters with the same conditions"
	| dict clusters analysis total |
	total := 0.
	analysis := Dictionary new.
	dict := Dictionary new.
	clusters := projectClusters clusters.
	projectClusters subclusters do: [:subcluster |
		(dict at: subcluster condition ifAbsentPut: [ Set new ]) add: subcluster ].
	dict keys do: [:condition | (dict at: condition) size = 1 ifTrue: [ dict removeKey: condition]].
	clusters do: [:cluster |
		| clusterDict |
		clusterDict := Dictionary new.
		analysis at: cluster clusterName put: clusterDict.
		dict keys do: [:condition | 
			| count |
			count := 0.
			((dict at: condition) collect: [:each | each subclusterName ]) do: [:subclusterName |
				(cluster subclusters includes: subclusterName) ifTrue: [ count := count + 1 ].
				count > 1 ifTrue: [ clusterDict at: subclusterName put: count -1 . total := total + count - 1 ].
			 ] ] ].
"	^ { total . analysis . self calculateStats: projectClusters against: resolvedProject }."
	^ (self validateProjectClusters: projectClusters against: resolvedProject)
			add: total;
			add: analysis;
			yourself
%
method
customAnalysis:  projectClusters against: resolvedProject
	^ self commonConditions: projectClusters against: resolvedProject
%
method
calculateStats: projectClusters against: resolvedProject
	| packageNames stats |
	packageNames:= resolvedProject packageNames.
	stats := Dictionary new.
	stats at: 'packages' put: packageNames size.
	stats at: 'clusters' put: projectClusters clusters size. 
	stats at: 'subclusters' put: projectClusters subclusters size. 
	stats at: 'components' put: resolvedProject _projectComponents components size.
	^ stats
%
method
validateProjectClusters: projectClusters against: resolvedProject
	| packageNames references |
	packageNames:= resolvedProject packageNames.
	references := Dictionary new.
	packageNames do: [:packageName |
		| refs |
		refs := projectClusters referencesToPackageNamed: packageName.
		references at: packageName put: refs ].
	self stats
		ifTrue: [ ^ { self calculateStats: projectClusters against: resolvedProject . references . projectClusters } ].
	^ {references . projectClusters }
%
method
analyzeClustersInProject: resolvedProject
"
	For each load component create an cluster, follow the chain of subcomponents, accumulating a conditional 
	expression for each component visited. When a component contains a package or project reference create 
	an subcluster to record the expression and references. Ideally I should be able identify shared subclusters.

	Running through process of converting the components to clusters and subclusers ... and returning 
	the _projectClusters object ... which when displayed with STON is pretty reasonable result.

  Will need to run against multiple projects work out the kinks and validate the approach.
"
	| projectClusters |
	projectClusters := resolvedProject clusterAnalysis.
	self custom
		ifTrue: [ ^ self customAnalysis: projectClusters against: resolvedProject  ].
	self validate
		ifTrue: [ ^ self validateProjectClusters: projectClusters against: resolvedProject ].
	self stats
		ifTrue: [ ^ { self calculateStats: projectClusters against: resolvedProject . projectClusters } ].
	^ projectClusters
%
doit
	| resolvedProject loadSpec loadComponentNames x calculated actual attributes context projectClusters res theAttributes |
	self projectsHome
		ifNil: [
			(System gemEnvironmentVariable: 'ROWAN_PROJECTS_HOME') 
				ifNil: [ self error: 'ROWAN_PROJECTS_HOME not definied. Define ROWAN_PROJECTS_HOME or use --projectsHome option' ] ]
		ifNotNil: [:rowanProjectsHome | System gemEnvironmentVariable: 'ROWAN_PROJECTS_HOME' put: rowanProjectsHome ].
	self positionalArgs size < 1 ifTrue: [ self error: 'Must provide the loadSpecUrl as first positional argument'].
	loadComponentNames := self positionalArgs copyFrom: 2 to: self positionalArgs size.
	
	loadSpec := (RwSpecification fromUrl: (self positionalArgs at: 1)) copyAsV4_cluster. 
	attributes := { 'v2' . 'tests' . 'testsV2' . 'gemstone' . 'common' }.	"common attributes"
	loadSpec addCustomConditionalAttributes: attributes.
	attributes := (attributes , loadSpec customConditionalAttributes) asSet asArray.
false ifTrue: [ 	attributes := (attributes , { 'gemstoneBase'}) asSet asArray ].
self projectName = 'RowanV3' ifTrue: [
	loadSpec 
		projectAlias: self projectName;
		diskUrl: ('$ROWAN_PROJECTS_HOME' asFileReference / self projectName) pathString;
		componentNames: loadComponentNames ]
ifFalse: [
	| baseProjectName |
	baseProjectName := 'RowanSample9V4'.
	self projectName = 'RowanSample9V4_0070'
		ifTrue: [
			attributes := attributes, { 'attr1' }.
			loadSpec addCustomConditionalAttributes: { 'attr1' }.
			loadSpec 
				projectAlias: baseProjectName;
				diskUrl: ('$ROWAN_PROJECTS_HOME' asFileReference / baseProjectName) pathString;
				componentNames: loadComponentNames]
		ifFalse: [
			| x1 x2 |
			self projectName = 'RowanSample9V4_0024'
				ifTrue: [
					loadSpec 
						projectAlias: baseProjectName;
						diskUrl: ('$ROWAN_PROJECTS_HOME' asFileReference / baseProjectName) pathString;
						componentNames: loadComponentNames ]
				ifFalse: [ 
						self projectName = 'RowanSample9V4_0032'
						ifTrue: [
							loadSpec 
								projectAlias: baseProjectName;
								diskUrl: ('$ROWAN_PROJECTS_HOME' asFileReference / baseProjectName) pathString;
								componentNames: loadComponentNames ]
						ifFalse: [ self error: 'Unknown label: ', self projectName printString, '. Expected RowanV3, RowanSample9V4_0070, RowanSample9V4_0024, or  RowanSample9V4_0032' ] ] ] ].
	resolvedProject := loadSpec read.
	context :=  resolvedProject expressionContext.
	theAttributes := attributes copy.
	attributes do: [:attribute |
		attribute = 'gemstone'
			ifTrue: [
				"define additional gemstone system attributes ala Rowan>>platformConditionalAttributes"
				context 
					set: attribute;
					set: 'gemstone-kernel';
					set: 'gemstone.version' to: ((System gemVersionReport at: 'gsVersion') asRwGemStoneVersionNumber);
					yourself.
				theAttributes 
					add: 'gemstone-kernel'; 
					add: (System gemVersionReport at: 'gsVersion') ]
			ifFalse: [ context set: attribute ] ].
	theAttributes := theAttributes asSet asArray. 
	projectClusters := resolvedProject projectDefinition clusterAnalysis.
	calculated := (self
				calculatePackageNamesFor: 'unused'
				clusters: loadComponentNames 
				projectClusters: projectClusters) asSet.
	actual := resolvedProject packageNames asSet.
	res := { 'attributes' -> theAttributes sort . 'dif A-C' -> (actual - calculated) sort . 'dif C-A' -> (calculated - actual) sort . 'actual' -> actual sort . 'calculated' ->calculated sort  . 'projectClusters' -> projectClusters }.
	self resultsFile asFileReference writeStreamDo: [:writeStream |
		writeStream truncate.
		(STONWriter new on: writeStream)
			prettyPrint: true;
			referencePolicy: #ignore;
			nextPut: res].
		^ true
%
