#!/usr/bin/env superdoit_stone
options
{
	SuperDoitOptionalOptionWithRequiredArg long: 'projectsHome'.
	SuperDoitOptionalOptionWithRequiredArg long: 'projectName'.
	SuperDoitOptionalOptionWithRequiredArg long: 'projectClusters'.
	SuperDoitRequiredOptionWithRequiredArg long: 'specUrl'.

	SuperDoitOptionalOptionWithNoArg long: 'validate'.
	SuperDoitOptionalOptionWithNoArg long: 'stats'.
	SuperDoitOptionalOptionWithNoArg long: 'packageNames'.
	SuperDoitOptionalOptionWithRequiredArg long: 'targetGemStoneVersion' default:'3.7.5'.
	SuperDoitOptionalOptionWithRequiredArg long: 'addedAttributes' .
	SuperDoitRequiredOptionWithRequiredArg long: 'resultsFile' .
}
%
#
#options
#{
#	SuperDoitOptionalOptionWithNoArg long: 'noarg'.
#	SuperDoitOptionalOptionWithNoArg long: 'noarg' short: 'n'.
#
#	SuperDoitOptionalOptionWithRequiredArg long: 'optional'.
#	SuperDoitOptionalOptionWithRequiredArg long: 'optional' default: 'default'.
#	SuperDoitOptionalOptionWithRequiredArg long: 'optional' short: 'o'.
#	SuperDoitOptionalOptionWithRequiredArg long: 'optional' short: 'o' default: 'default'.
#
#	SuperDoitRequiredOptionWithRequiredArg long: 'required'.
#	SuperDoitRequiredOptionWithRequiredArg long: 'required' short: 'r'.
#}
#%
#
usage
-----
USAGE 
  # with GS_HOME set (<stone-name> optional if run in $GS_HOME/servers/stones/<stone-name> directory)
  $basename [--help | -h] [--debug | -D]  [--debugGem] [-- [<stone-name> [<topaz-command-line-args>] ] ]
  # with GEMSTONE set
  $basename [--help | -h] [--debug | -D]  [--debugGem] -- (-r | -l | -L) -I <path-to-.topazini> [<topaz-command-line-args>]

DESCRIPTION
  reorgRowanCluster.stone takes a generated/rowanV3_Rowan_components.ston file 
  and produces an idealRowanV3_Rowan_components.ston file, which represents an 
  instance of RwResolvedProjectClusters with several RwSlices defined: RowanV3.5, 
  RowanV4.0, RowanV4.0_loaded, and RowanV3.5_upgrade.

  This script will take a slice name from the command line and produce a list of packages 
  that should be loaded by the slice.

	Using the --validate option will arrange to have the package list produced by 
  the slice compared to a RowanV3.5 load of the equvalent Components.

OPTIONS
  <stone-name>               Name of the GsDevKit_home stone. <stone-name> argument
                             may be skipped if the script is run in a GsDevKit_home
                             stone directory (i.e., $GS_HOME/server/stones/<stone-name>
  <topaz-command-line-args>  topaz options that should be passed to topaz when running
                             running the script
  -h, --help                 display usage message
  -D, --debug                bring up topaz debugger in the event of a script error
  --debugGem                 If terminal is connected to stdout, bring up debugger. If not,
                             dump stack to stdout and wait for topaz to attach using topaz
                             DEBUGGEM command.

EXAMPLES
  $basename --help                           -- gs_351             # with GS_HOME set
  $basename -h                               -- -l -I ./.topazini  # with GEMSTONE set
  $basename -D <script-arguments>            <topaz-arguments>
  $basename --debugGem <script-arguments>    <topaz-arguments>
  $basename <script-arguments>               <topaz-arguments>

	# Rowan:masterV3.5 - Rowan
  $basename --projectsHome=/bosch1/users/dhenrich/_stones/git/ \
            --projectName=RowanV3 \
            --specUrl=file:///bosch1/users/dhenrich/_stones/git/RowanV3/rowan/specs/Rowan.ston \
            --projectClusters='/bosch1/users/dhenrich/_stones/git/RowancelloSample1/generated/idealRowanV3_Rowan_components.ston' \
            --resultsFile='/bosch1/users/dhenrich/_stones/git/RowancelloSample1/generated/idealRowanV3_Upgrade_packages.ston' \
            --addedAttributes=upgrade
            RowanV3.5 Upgrade -D

  -----
%
method
calculatePackageNamesFor: unused slices: sliceNames projectClusters: projectClusters
	| packageNames context subcluster|
	context := projectClusters expressionContext.
	packageNames := Set new.
	sliceNames do: [:sliceName |
		| slice ast evaluator stack index|
		slice := projectClusters sliceNamed: sliceName.
		packageNames addAll: slice packageNames.
		slice subclusterNames do: [:subclusterName |
			subcluster := projectClusters sliceNamed: subclusterName.
    	ast := RwCAQParser new parse: subcluster condition.                           
   		evaluator := RwCAQEvaluator
   			context: context
   			ast: ast.
      (evaluator evaluate)
				ifTrue: [ packageNames addAll: subcluster packageNames ] ] ].
	^ packageNames sort
%
method
commonConditions: projectClusters against: resolvedProject
	"looking for subclusters with the same conditions"
	| dict clusters analysis total |
	total := 0.
	analysis := Dictionary new.
	dict := Dictionary new.
	clusters := projectClusters clusters.
	projectClusters subclusters do: [:subcluster |
		(dict at: subcluster condition ifAbsentPut: [ Set new ]) add: subcluster ].
	dict keys do: [:condition | (dict at: condition) size = 1 ifTrue: [ dict removeKey: condition]].
	clusters do: [:cluster |
		| clusterDict |
		clusterDict := Dictionary new.
		analysis at: cluster clusterName put: clusterDict.
		dict keys do: [:condition | 
			| count |
			count := 0.
			((dict at: condition) collect: [:each | each subclusterName ]) do: [:subclusterName |
				(cluster subclusters includes: subclusterName) ifTrue: [ count := count + 1 ].
				count > 1 ifTrue: [ clusterDict at: subclusterName put: count -1 . total := total + count - 1 ].
			 ] ] ].
"	^ { total . analysis . self calculateStats: projectClusters against: resolvedProject }."
	^ (self validateProjectClusters: projectClusters against: resolvedProject)
			add: total;
			add: analysis;
			yourself
%
method
customAnalysis:  projectClusters against: resolvedProject
	^ self commonConditions: projectClusters against: resolvedProject
%
method
calculateStats: projectClusters against: resolvedProject
	| packageNames stats |
	packageNames:= resolvedProject packageNames.
	stats := Dictionary new.
	stats at: 'packages' put: packageNames size.
	stats at: 'clusters' put: projectClusters clusters size. 
	stats at: 'subclusters' put: projectClusters subclusters size. 
	stats at: 'components' put: resolvedProject _projectComponents components size.
	^ stats
%
method
validateProjectClusters: projectClusters against: resolvedProject
	| packageNames references |
	packageNames:= resolvedProject packageNames.
	references := Dictionary new.
	packageNames do: [:packageName |
		| refs |
		refs := projectClusters referencesToPackageNamed: packageName.
		references at: packageName put: refs ].
	self stats
		ifTrue: [ ^ { self calculateStats: projectClusters against: resolvedProject . references . projectClusters } ].
	^ {references . projectClusters }
%
method
analyzeClustersInProject: resolvedProject
"
	For each load component create an cluster, follow the chain of subcomponents, accumulating a conditional 
	expression for each component visited. When a component contains a package or project reference create 
	an subcluster to record the expression and references. Ideally I should be able identify shared subclusters.

	Running through process of converting the components to clusters and subclusers ... and returning 
	the _projectClusters object ... which when displayed with STON is pretty reasonable result.

  Will need to run against multiple projects work out the kinks and validate the approach.
"
	| projectClusters |
	projectClusters := resolvedProject clusterAnalysis.
	self custom
		ifTrue: [ ^ self customAnalysis: projectClusters against: resolvedProject  ].
	self validate
		ifTrue: [ ^ self validateProjectClusters: projectClusters against: resolvedProject ].
	self stats
		ifTrue: [ ^ { self calculateStats: projectClusters against: resolvedProject . projectClusters } ].
	^ projectClusters
%
method
calculateDuplicateSubclusterConditions: subclusters reportOn: resultArray
	| duplicateConditions collected total noDupe |
	noDupe := total := 0.
	duplicateConditions := Dictionary new.
	subclusters values do: [:subcluster |
		| theCondition duplicates |
		duplicates := IdentitySet new.
		duplicateConditions at: subcluster condition put:duplicates.
		theCondition := subcluster condition.
		duplicates addAll: (subclusters selectValues: [:sample | sample condition = theCondition ])].
	collected := Dictionary new.
	duplicateConditions 
		keysAndValuesDo: [:condition :theSubclusters |
			| names |
			names := (theSubclusters collect: [:each | each subclusterName]) sort.
			names size > 1 
				ifTrue: [ 
					collected at: condition put: names.
					total := total + names size ]
				ifFalse: [ noDupe := noDupe + 1 ] ].
	resultArray 
		add: ('COMMENT' -> (collected keys size printString, ' conditions shared by  ', total printString, ' subclusters out of ', subclusters size printString, ' . That leaves ', noDupe printString, ' singleton subclusters, for a total of ', (collected keys size + noDupe) printString, ' subclusters needed, instead of ', subclusters size printString, '. If the conditions can be shared :).'));
		add: ('duplicateConditions' -> collected). 
%
method
sortProjectClusterFields: projectClusters
	"alphabetically sort all of the arrays in projectClusters"
	 projectClusters clusters keysAndValuesDo: [:clusterName :cluster |
			cluster subclusters: cluster subclusters sort ].
	
%
doit
	| resolvedProject loadSpec sliceName loadComponentNames x calculated actual attributes context projectClusters res theAttributes |
	self projectsHome
		ifNil: [
			(System gemEnvironmentVariable: 'ROWAN_PROJECTS_HOME') 
				ifNil: [ self error: 'ROWAN_PROJECTS_HOME not definied. Define ROWAN_PROJECTS_HOME or use --projectsHome option' ] ]
		ifNotNil: [:rowanProjectsHome | System gemEnvironmentVariable: 'ROWAN_PROJECTS_HOME' put: rowanProjectsHome ].
	self positionalArgs size < 2 ifTrue: [ self error: 'Must provide the sliceName and component name positional arguments'].
	sliceName := self positionalArgs at: 1.
	loadComponentNames := {self positionalArgs at: 2}.
	loadSpec := (RwSpecification fromUrl: self specUrl) copyAsV4_cluster. 
	attributes := { 'v2' . 'tests' . 'testsV2' . 'gemstone' . 'common' }.	"common attributes"
	self addedAttributes
		ifNotNil: [:added |
			(added subStringsDelimitedBy: Character space)
				do: [ :addedAttribute | 
					attributes add: addedAttribute]].
	loadSpec addCustomConditionalAttributes: attributes.
	attributes := (attributes , loadSpec customConditionalAttributes) asSet asArray.
self projectName = 'RowanV3' ifTrue: [
	loadSpec 
		projectAlias: self projectName;
		diskUrl: ('$ROWAN_PROJECTS_HOME' asFileReference / self projectName) pathString;
		componentNames: loadComponentNames ]
ifFalse: [
	| baseProjectName |
	baseProjectName := 'RowanSample9V4'.
	self projectName = 'RowanSample9V4_0070'
		ifTrue: [
			attributes := attributes, { 'attr1' }.
			loadSpec addCustomConditionalAttributes: { 'attr1' }.
			loadSpec 
				projectAlias: baseProjectName;
				diskUrl: ('$ROWAN_PROJECTS_HOME' asFileReference / baseProjectName) pathString;
				componentNames: loadComponentNames]
		ifFalse: [
			| x1 x2 |
			self projectName = 'RowanSample9V4_0024'
				ifTrue: [
					loadSpec 
						projectAlias: baseProjectName;
						diskUrl: ('$ROWAN_PROJECTS_HOME' asFileReference / baseProjectName) pathString;
						componentNames: loadComponentNames ]
				ifFalse: [ 
						self projectName = 'RowanSample9V4_0032'
						ifTrue: [
							loadSpec 
								projectAlias: baseProjectName;
								diskUrl: ('$ROWAN_PROJECTS_HOME' asFileReference / baseProjectName) pathString;
								componentNames: loadComponentNames ]
						ifFalse: [ self error: 'Unknown label: ', self projectName printString, '. Expected RowanV3, RowanSample9V4_0070, RowanSample9V4_0024, or  RowanSample9V4_0032' ] ] ] ].
	resolvedProject := loadSpec read.
	context :=  resolvedProject expressionContext.
	theAttributes := attributes copy.
	attributes do: [:attribute |
		attribute = 'gemstone'
			ifTrue: [
				"define additional gemstone system attributes ala Rowan>>platformConditionalAttributes"
				context 
					set: attribute;
					set: 'gemstone-kernel';
					set: 'gemstone.version' to: (self targetGemStoneVersion asRwGemStoneVersionNumber);
					yourself.
				theAttributes
					add: 'gemstone-kernel';
					add: self targetGemStoneVersion ]
			ifFalse: [ context set: attribute ] ].
	theAttributes := theAttributes asSet asArray.
	projectClusters := self projectClusters asFileReference readStreamDo: [:stream | STON fromStream: stream].
	self sortProjectClusterFields: projectClusters.
	calculated := (self
				calculatePackageNamesFor: 'unused'
				slices: { sliceName } 
				projectClusters: projectClusters) asSet.
	actual := resolvedProject packageNames asSet.
	res := { 'attributes' -> theAttributes sort . 'dif A-C' -> (actual - calculated) sort . 'dif C-A' -> (calculated - actual) sort . 'actual' -> actual sort . 'calculated' ->calculated sort  . 'projectClusters' -> projectClusters }.
	self resultsFile asFileReference writeStreamDo: [:writeStream |
		writeStream truncate.
		(STONWriter new on: writeStream)
			prettyPrint: true;
			referencePolicy: #ignore;
			nextPut: res].
		^ true
%
