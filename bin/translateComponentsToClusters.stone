#!/usr/bin/env superdoit_stone
options
{
	SuperDoitOptionalOptionWithRequiredArg long: 'projectsHome'.
}
%
#
#options
#{
#	SuperDoitOptionalOptionWithNoArg long: 'noarg'.
#	SuperDoitOptionalOptionWithNoArg long: 'noarg' short: 'n'.
#
#	SuperDoitOptionalOptionWithRequiredArg long: 'optional'.
#	SuperDoitOptionalOptionWithRequiredArg long: 'optional' default: 'default'.
#	SuperDoitOptionalOptionWithRequiredArg long: 'optional' short: 'o'.
#	SuperDoitOptionalOptionWithRequiredArg long: 'optional' short: 'o' default: 'default'.
#
#	SuperDoitRequiredOptionWithRequiredArg long: 'required'.
#	SuperDoitRequiredOptionWithRequiredArg long: 'required' short: 'r'.
#}
#%
#
usage
-----
USAGE 
  # with GS_HOME set (<stone-name> optional if run in $GS_HOME/servers/stones/<stone-name> directory)
  $basename [--help | -h] [--debug | -D]  [--debugGem] [-- [<stone-name> [<topaz-command-line-args>] ] ]
  # with GEMSTONE set
  $basename [--help | -h] [--debug | -D]  [--debugGem] -- (-r | -l | -L) -I <path-to-.topazini> [<topaz-command-line-args>]

DESCRIPTION
  <put your description here>

OPTIONS
  <stone-name>               Name of the GsDevKit_home stone. <stone-name> argument
                             may be skipped if the script is run in a GsDevKit_home
                             stone directory (i.e., $GS_HOME/server/stones/<stone-name>
  <topaz-command-line-args>  topaz options that should be passed to topaz when running
                             running the script
  -h, --help                 display usage message
  -D, --debug                bring up topaz debugger in the event of a script error
  --debugGem                 If terminal is connected to stdout, bring up debugger. If not,
                             dump stack to stdout and wait for topaz to attach using topaz
                             DEBUGGEM command.

EXAMPLES
  $basename --help                           -- gs_351             # with GS_HOME set
  $basename -h                               -- -l -I ./.topazini  # with GEMSTONE set
  $basename -D <script-arguments>            <topaz-arguments>
  $basename --debugGem <script-arguments>    <topaz-arguments>
  $basename <script-arguments>               <topaz-arguments>

  $basename --projectsHome=/bosch1/users/dhenrich/_stones/git/ \
            file:///bosch1/users/dhenrich/_stones/git/RowancelloSample1/rowanSupport/rowan/specs/RowancelloSample1.ston \
            /bosch1/users/dhenrich/_stones/git/RowancelloSample1/rowan \
            -D
  # translate the 
  $basename --projectsHome=/bosch1/users/dhenrich/_stones/git/ \
            file:///bosch1/users/dhenrich/_stones/git/RowanV3/rowan/specs/Rowan.ston \
            /bosch1/users/dhenrich/_stones/git/RowanV3/rowan \
            Rowan SharedTests Upgrade
            -D
-----
%
instvars
rowanRoot
%
method
translateComponentsInProjectToClusters: toplevelComponentNames resolvedProject: resolvedProject
	toplevelComponentNames do: [:componentName |
		(resolvedProject componentNamed: componentName)
			populateClustersForProject: resolvedProject ].
	toplevelComponentNames do: [:componentName |
		| component |
		component := resolvedProject componentNamed: componentName.
		(component condition ~= 'common')
			ifTrue: [ 
				component
					populateSubclustersForProject: resolvedProject
						conditions: {(component clusterCondition)}
						clusterName: componentName ] ].
%
method
translateComponentsInProjectToClusters: resolvedProject
	"translate the components in the resolvedProject into clusters and subclusters"
self halt: 'when this guy is used, we need to traverse all of the "top-level" components ... so perhaps require at least one top-level component name?'
	resolvedProject _projectComponents do: [:component |
		component populateClustersForProject: resolvedProject ].
%
method
exportClusterStructuresFor: resolvedProject
	resolvedProject _projectClusters clusters keysAndValuesDo: [:clusterName :cluster |
		| filename |
		filename := rowanRoot / 'clusters' / clusterName , 'ston'.
		filename parent ensureCreateDirectory.
		filename writeStreamDo: [:fileStream |
			fileStream truncate.
			STON put: cluster onStreamPretty: fileStream ] ].
	resolvedProject _projectClusters subclusters keysAndValuesDo: [:subclusterName :subcluster |
			| filename |
		filename := rowanRoot / 'subclusters' / subclusterName , 'ston'.
		filename parent ensureCreateDirectory.
		filename writeStreamDo: [:fileStream |
			fileStream truncate.
			STON put: subcluster onStreamPretty: fileStream ] ].
%
doit
	| resolvedProject loadSpec loadComponentNames |
	self projectsHome
		ifNil: [
			(System gemEnvironmentVariable: 'ROWAN_PROJECTS_HOME') 
				ifNil: [ self error: 'ROWAN_PROJECTS_HOME not definied. Define ROWAN_PROJECTS_HOME or use --projectsHome option' ] ]
		ifNotNil: [:rowanProjectsHome | System gemEnvironmentVariable: 'ROWAN_PROJECTS_HOME' put: rowanProjectsHome ].
	self positionalArgs size < 2 ifTrue: [ self error: 'Must provide the loadSpecUrl as first positional argument and rowanRoot (location where clusters and subclusters directories will be created'].
	loadComponentNames := self positionalArgs copyFrom: 3 to: self positionalArgs size.
	loadSpec := (RwSpecification fromUrl: (self positionalArgs at: 1)) copyAsV4_cluster. 
	"note when reading from disk we have to make sure that ALL components are read from disk 
		so we have to arrange to set all of the conditions to true - eventually need to set on command line?"
	loadSpec 
		diskUrl: ('$ROWAN_PROJECTS_HOME' asFileReference / 'RowanV3') pathString;
		addCustomConditionalAttributes: { 'tests' };
		componentNames: loadComponentNames.
	resolvedProject := loadSpec read.
  rowanRoot := (self positionalArgs at: 2) asFileReference.
	self positionalArgs size > 2
		ifTrue: [ 
			self 
				translateComponentsInProjectToClusters: loadComponentNames
				resolvedProject: resolvedProject projectDefinition ]
		ifFalse: [ self translateComponentsInProjectToClusters: resolvedProject projectDefinition ].
  self exportClusterStructuresFor: resolvedProject.
	^ self noResult
%
